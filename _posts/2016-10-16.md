---
title:        "软件架构"
description:  "A short description of the page's content"
image:        "http://placehold.it/400x200"
author:       "GeekMeng"
---

软件架构
============

>一般好的架构可以尽量使变化发生在局部（模块内）而不影响整个系统。架构上的变化往往成本会非常高。
>架构则着眼于更全局的高度，包括硬件，操作系统，网络环境，包括从立项到维护之间的所有过程（需求，设计，编码，部署，维护，功能迭代等）。架构的责任是保证软件的可用性，可扩展性，可伸缩性，安全等等
>
>
>而且设计模式只有一些是适用于架构的，还有一些事用于具体的类设计的，剩下的一些则只是克服编程语言的限制而已。
>设计模式，使代码的耦合度达到最大限度的分离，从而可以使代码更好的被复用，更容易被替换，更好的拥抱需求的变化。
>
>


设计模式
============

>模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。【A pattern is a successful or efficient solution to a recurring  problem within a context】
>

* 模式名称(`Pattern Name`)通过一两个词来描述模式的问题、解决方案和效果，以便更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的
* 问题(`Problem`)描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因；
* 解决方案(`Solution`)描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码来进行描述；
* 效果(`Consequences`)描述了模式的优缺点以及在使用模式时应权衡的问题。

根据它们的用途，设计模式可分为:

  * 创建型(`Creational`)：主要用于描述如何创建对象
  * 结构型(`Structural`)：主要用于描述如何实现类或对象的组合
  * 为型(`Behavioral`)：主要用于描述类或对象怎样交互以及怎样分配职责

常见设计模式：

|类型     |模式名称|
|--------|---------|
|创建型模式|单例模式(`Singleton Pattern`)、简单工厂模式(`Simple Factory Pattern`)、工厂方法模式、抽象工厂模式、原型模式、建造者模式(`Builder Pattern`)|
|结构型模式|适配器模式、桥接模式(`Bridge Pattern`)、组合模式、装饰模式、外观模式、享元模式、代理模式(`Proxy Pattern`)|
|行为型模式|职责链模式、命令模式(`Command Pattern`)、解析器模式、迭代器模式、中介者模式、备忘录模式、观察者模式(`Observer Pattern`)、状态模式、策略模式(Strategy Pattern)、模板方法模式(`Template Method Pattern`)、访问者模式|


>模式从不保证任何东西，它不能保证你一定能够做出可复用的软件，提高你的生产率，更不能保证世界和平。模式并不能替代人来完成软件系统的创造，它们只不过会给那些缺乏经验但却具备才能和创造力的人带来希望。
>


* 如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。

常用的面向对象的设计原则：

|设计原则名称                                     |定义                                     |
|-----------------------------------------------|----------------------------------------|
|单一职责原则(Single Responsibility Principle,SRP)|一个类只负责一个功能领域中的相应职责          |
|开闭原则(Open-Closed Principle,OCp)             |软件实体应对扩展开放，而对修改关闭            |
|里氏代换原则(Liskov Substitution Principle,LSP)  |所有引用基类对象的地方能够透明地使用其子类的对象|
|依赖倒转原则(Dependence Inversion Principle,DIP) |抽象不应该依赖于细节，细节应该依赖于抽象       |
|接口隔离原则(Interface Segregation Principle,ISP)|使用多个专门的接口，而不是用单一的总接口       |
|合成复用原则(Composite Reuse Principle,CRP)      |尽量使用对象组合，而不是继承来达到复用的目的    |
|迪米特法则(Law of Demeter,LoD)                   |一个软件实体应当尽可能少地与其他实体发生相互作用|


* 1.单一职责原则：
一个类只负责一个功能领域中的响应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。

单一职责原则是实现高内聚、低耦合的指导方针。

>单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。
>


* 2.开闭原则：
一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

软件实体：可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。

>任何软件都面临的一个问题：它们的需求会随时间的推移而发生变化。
>当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。
>如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要
> 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。
>可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。
>


# 3.里氏代换原则:
所有引用基类（父类）的地方必须能透明地使用其子类的对象。

在软件中，将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。

>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。
>


# 4.依赖倒转原则:
抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。


[设计模式](http://blog.csdn.net/lovelion/article/details/17517213)


☺







## 完 ##
